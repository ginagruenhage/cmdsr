#Weird effect using stepfunctions

Let's build a distance matrix based constant functions with even spacing:

```{r}
DL1 <- replicate(5,a.m(dist(c(0,1,2,3,4))))
DL1 <- alply(DL1,3,function(d) d)
```
As expected, cmds can perfectly embed these distances in k=1 dimensions:
```{r}
plot.cmds(cmds(DL1,k=1,l=0))
```

Let's glue a second set of constant functions to the first set, but with double the spacing.

```{r}
DL2 <- replicate(5,a.m(dist(c(0,2,4,6,8))))
DL2 <- alply(DL2,3,function(d) d)
plot.cmds(cmds(DL2,k=1,l=0))
plot.cmds(cmds(c(DL1,DL2),k=1,l=0))
```
That also works fine.

Now, let's take functions with random y intercept:
```{r}
set.seed(3)
vec <- rnorm(5,sd=2)
DL3 <- replicate(5,a.m(dist(vec)))
DL3 <- alply(DL3,3,function(d) d)
plot.cmds(cmds(DL3,k=1,l=0))
```
That works. However, if we combine this distance list with one of the previous one, the algorithm fails in the second case:
```{r}
plot.cmds(cmds(c(DL1,DL3),k=1,l=0),shepard=TRUE)
res <- cmds(c(DL2,DL3),k=1,l=0,v=T)
plot.cmds(res,shepard=TRUE)
```
To check wether this result is a local minimum of the cost function, I wrote three auxiliary functions:
```{r}
# transform the embedding list to a numeric vector
XL2num <- function(XL){
  a.n(laply(XL,function(x) as.numeric(x)))
}

# wrapper for C.L (which computes the cost in the cmds algorithm), that takes a numeric vector as first argument
Cost <- function(x,DL,params){
  XL <- x2list(x,params)
  C.L(DL, XL, params)
}

# calculates the numerical gradient and checks whether it's equal to zero with numerical tolerance
check.local.minimum <- function(res){
  x <- XL2num(res$XL)
  n <- length(x)
  g <- grad(Cost, x, DL = res$DL, params = res$params)
  
  if (all.equal(rep(0,n),g)){
    cat("The result is a local minimum of the cost function.\n")
  } else {
    cat("The automatic test for local minimum failed. \n You are now in a browser to check the actual value of the numerical gradient, g.\n")
    browser()
  }
}
```
The weird result is really a local minimum:
```{r}
check.local.minimum(res)
```

Iit seems to depend on the values in the random vector wether it works or not, for other random vectors I didn't get this effect. For example:
```{r}
set.seed(20)
vec <- rnorm(5,sd=2)
DL3 <- replicate(5,a.m(dist(vec)))
DL3 <- alply(DL3,3,function(d) d)
plot.cmds(cmds(c(DL1,DL3),k=1,l=0),shepard=TRUE)
plot.cmds(cmds(c(DL2,DL3),k=1,l=0),shepard=TRUE)
```